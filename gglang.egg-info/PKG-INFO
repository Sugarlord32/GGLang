Metadata-Version: 2.4
Name: gglang
Version: 0.1.0
Summary: An interpreter for the gglang programming language.
Home-page: https://github.com/example/gglang
Author: Jules
Author-email: jules@example.com
Description-Content-Type: text/markdown
Requires-Dist: lark-parser
Dynamic: author
Dynamic: author-email
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: requires-dist
Dynamic: summary

# GGLang Prototype

This repository contains a working prototype of the GGLang interpreter, built in Python using the Lark parsing library. This document outlines the current state of the language, detailing which features from the design document have been implemented and which are still pending or disabled.

## How to Use

To run a GGLang script, use the `main.py` interpreter from the command line:

```bash
python main.py <filename.gg>
```

You can also enable debug logging to trace the interpreter's execution:
```bash
python main.py --debug <filename.gg>
```

## Current Status

The interpreter is in a stable state and can successfully execute scripts that use the implemented features. Most of the language features described in the original design are now implemented. A comprehensive test suite (`tests/examples/full_suite.gg`) is included.

Some features, such as the boolean shorthand (`?`) and a full implementation of pragmatic references (`&`), remain unimplemented due to parsing ambiguities in the Lark library.

## Implemented Features

The following features are fully implemented and tested:

### Core Syntax
*   **Variables:** `var x: int = 100`, `var y := "hello"`
*   **Constants:** `const PI := 3.14159`
*   **Uninitialized Variables:** `var health: int` (with runtime checks for use before assignment).
*   **Types:** `int`, `float`, `str`, `bool`, `void`.
*   **Comments:** `# this is a comment`
*   **Booleans:** `true`, `false`

### Functions
*   **Declaration:** `fn add(x: int, y: int) -> int { ... }`
*   **`return` statements:** `return x + y`
*   **Block-based bodies:** using `{ ... }`
*   **`main` function entry point:** Execution starts in `fn main()`.
*   **Lexical Scoping (Closures):** Functions capture the environment they are defined in.

### Expressions
*   **Arithmetic Operators:** `+`, `-`, `*`, `/` (with integer division for two integer operands).
*   **Comparison Operators:** `==`, `!=`, `<`, `>`, `<=`, `>=` with correct precedence.
*   **Ternary Operator:** `condition ? true_val : false_val` (right-associative).
*   **String Interpolation:** `i"Hello, #{name}"`.

### Pipe Operators
*   **Standard Pipe (`-->`):** Passes values from left to right.
*   **Coercion Pipe (`~~>`):** Performs type coercion based on the receiving function's signature.
*   **Assignment Pipes:**
    *   `... -:> result` (assigns to an existing or new variable).
    *   `... --> result: int` (declares and assigns to a new typed variable).
*   **Pipe Modifiers (`{n}` and `if`):** `... --> add(_, 5){3}`, `... --> process(_) if _ > 0`

### Data Structures
*   **Arrays:** `[1, 2, "three"]` (via Python lists).
*   **Array Access:** `my_array[0]`.
*   **Dictionaries:** `{ "key": "value" }` (keys can be strings or integers).

### Control Flow
*   **`for` loops:** `for item in my_array { ... }` (iterates over a copy of the list to prevent mutation issues).
*   **Error Handling:** `try { ... } catch e { ... }`
*   **`if` statements:** `if condition { ... } else { ... }`

### Classes and Inheritance
*   **Class Declaration:** `class MyClass { ... }`
*   **Inheritance:** `class SubClass extends MyClass { ... }`
*   **Instance Variables:** `@my_var` (declared and used within methods).
*   **Method Calls:** `my_instance.my_method()`
*   **Superclass Method Calls:** `super.my_method()`

### Built-in Functions
*   `print()`
*   `len()`
*   `assert()`
*   `int()`, `str()`, `float()` for type conversions.
*   `upper()`, `lower()` as string methods.
*   `append()`, `pop()`, `remove()` for lists.
*   `type()` for inspecting value types.
*   `input()` for reading from stdin.


## Unimplemented / Disabled Features

*   **Boolean Shorthand (`?`):** The `expression? { ... }` syntax was replaced with a more standard `if expression { ... }` to resolve a parsing ambiguity.
*   **Pragmatic References (`&`):** A full implementation of references was deferred due to complexity. The syntax is currently parsed but not fully functional (no read-only checks are enforced).
*   **`import` and `extends`:** The full module and file-level inheritance system was not implemented.
*   **Indentation-based Syntax:** An attempt was made to switch from `{}` to indentation, but it failed due to insurmountable issues with the parsing library's `IndentedLexer`. The language currently uses `{}` for blocks.
*   **Static Type Checking:** Only very basic type checking on variable declaration is implemented. A full static type checker is a future goal.
